CPU 논리 프로세서 (하이퍼쓰레드)
	. 가상 코어
	. 하나의 코어에서 두 개의 쓰레드 사용

컴퓨터
. 직렬 컴퓨터
	- 하나의 CPU(또는 Core)만을 갖는 컴퓨터
	- 듀얼코어가 대중화 되기 이전의 대부분의 컴퓨터
	- 현재 멸종

. 병렬 컴퓨터
	- 여러 개의 CPU(또는 Core)가 명령들을 실행하는 컴퓨터
	- 직렬 컴퓨터의 속도 제한을 극복하기 위해 제작

. 병렬 컴퓨터의 사용 목적
	- 여러 개의 작업을 보다 빨리 실행하기 위해서
	  . 여러 대의 컴퓨터를 사용해도 됨 -> 더 싸다
	- 하나의 작업을 보다 빨리 실행하기 위해서

. 병렬 프로그램
	- 기존의 프로그램을 병렬 컴퓨터에서 실행했을 경우 속도 증가는 0%
	- 동시에 여러 개의 명령 흐름이 실행되는 것을 가정하고 다시
	프로그래밍 해야 한다. -> 병렬 프로그래밍

. 병렬 프로그램의 특징
	- 실행된 프로세스의 내부 여러 곳이 동시에 실행됨
	- 병렬로 실행되는 객체(Context로 불림) 사이의 협업이 필수
	- 크게 공유메모리(Shared Memory) 모델과 메시지 패싱(Message Passing) 모델이 있음
	- 우리가 다루는 것은 공유 메모리 모델

. 병렬 프로그램 요구사항 : 정확성과 성능
	- 여러 흐름(Context)에서 동시 다발적으로 호출해도 문제 없이 실행되는
	알고리즘이 필요.
	  . 오류가 발생하면 모든 것이 의미 없음
	- Context의 증가에 따른 성능 향상이 높아야 한다.
	  . 기존의 직렬 프로그램보다 느려질 수 있다.


멀티쓰레드 프로그래밍
	- 현재 운영체제에서 병렬 프로그래밍의 (유일한) 구현 수단
	- 하나의 프로세스 안에서 여러 개의 쓰레드를 실행 시켜 병렬성을 얻는 프로그래밍 방법
	- Windows, Linux, Android, iOS에서 기본으로 제공하는 유일한 병렬 프로그래밍 API
	  . HW와 운영체제가 직접 지원하는 것은 이것 뿐
	  . 다른 API로는 GPGPU가 있음.

. 프로세스
	- 운영체제는 사용자의 프로그램을 프로세스 단위로 관리한다.
	- 실행파일의 실행 -> 운영체제가 파일 내용을 메모리에 복사 후 시작 주소로 점프하는 것.
	  . 읽어 들일 때 여러 가지 초기화가 필요하다.
	- 시분할 운영체제는 여러 프로세스를 고속으로 번갈아 가면서 실행한다.
	  . 실행중인 프로세스의 상태를 강제로 준비(Ready)로 변경 가능
	- 프로세스의 메모리 구조는 다음과 같다
	  . Code : 실행될 명령어가 들어가는 구역
	  . Data : 전역변수가 들어가는 구역
	  . Stack : 지역변수와 함수 리턴 주소가 들어가는 구역
	  . Heap : malloc이나 new로 할당 받은 메모리가 들어가는 구역
	  . PCB : Process Control Block

. 프로세스와 쓰레드
	- 프로세스는 초기에 하나의 시작 쓰레드를 가짐
	- 쓰레드는 다른 쓰레드를 만들 수 있다.
	- 쓰레드 생성은 프로그래머가 지시한다.
	- 모든 쓰레드는 자신 고유의 Stack을 가지고 있고, Data와 Code를 공유한다.
	- 쓰레드는 CPU에서 하드웨어적으로 관리된다. (x86)

. 프로세스에 비한 쓰레드의 장점
	- 생성 Overhead가 적다
	- Context Switch Overhead가 적다.
	  . Virtual memory (TLB 교체 오버헤드)
	- 쓰레드간의 통신이 간단하다.
. 쓰레드의 단점
	- 하나의 쓰레드에서 발생한 문제가 전체 프로세스를 멈추게 한다.
	- 디버깅이 어렵다.

. 멀티 쓰레드의 사용 목적
	- 멀티 코어 CPU에서의 프로그램 성능향상
	- 멀티 CPU 컴퓨터에서의 프로그램 성능 향상
	- (아님) 분산 컴퓨터에서의 프로그램 성능 향상
	  . 컴퓨터 여러 대를 네트워크로 연결한 것이 분산 컴퓨터임
	- (아님) 싱글 코어(CPU) 컴퓨터 환경에서의 프로그램 성능향상
	  . 그렇게 느껴진다면 원본 프로그램이 문제가 있는 것
	- (아님) 프로그램을 모듈화 해서 알아보기 쉽게

멀티코어 CPU
. 한 개 이상의 코어로 구성된 CPU를 뜻함.


멀티코어 프로세서

. Intel과 ARM에서 멀티코어 프로세서를 만드는 이유
	- CPU의 성능을 올려야 한다.
	  . 안 그러면 아무도 안 산다.
	- 클럭 속도를 높일 수 없다.
	  . 발열 문제(물리법칙)
	- 클럭 속도 말고 CPU의 속도를 올리는 법
	  . 아키텍처 개선 : 캐시, 파이프라인, 예측 분기, 동적수행
	- 남은 방법
	  . 멀티코어

. 멀티코어 프로세서의 코어
	- ALU + Register + CU + Cache
	- 그냥 CPU와 똑같다.

. 왜 이렇게 늦게 나왔는가
	- 프로그래머가 싫어하기 때문
	  . 프로그램을 다시 작성하지 않으면 성능향상 0
	  . 전혀 다른 알고리즘들을 사용해야 한다.
	  . 디버깅이 더럽게 어렵다.
	- 옛날부터 있었다.

. 현재
	- 4 Core가 대세
	  . 2017년부터 코어 개수 급속 증가.

. 멀티코어 이전의 병렬 컴퓨터
	- SMP(Symmetric Multi Processor) Computer
	  . 컴퓨터 안에 CPU가 여러 개 꽂혀 있고, 각 CPU는 동등한 입장에서 명령을 처리한다.
	  . 1962년 첫 시제품

. 프로그래밍 방법이 바뀌어야 한다
	- 기존의 프로그램을 듀얼 코어 CPU에서 실행하였다.
	  속도 향상은 얼마인가? -> 0%
	- 멀티쓰레드 프로그래밍을 해야 한다.
	- 좋은 멀티쓰레드 프로그래밍이란?
	  . Core의 개수에 비례해서 실행속도 증가


멀티쓰레드 프로그래밍

. 프로그래밍 방법
	- C++ 프로그래밍 언어에 멀티쓰레드 라이브러리가 표준으로 존재
	- 2011년도에 새로운 C++ 언어의 표준으로 C++11이 공표되었음
	- 표준 C++ 언어를 지원하는 컴파일러라면 하드웨어나 운영체제에
	  관계 없이 사용

. 자기 자신
	- this_thread : 주의)name_space임
	- this_thread의 API
	  . get_id() : 자기 자신의 thread_id
	  . sleep_for() : 정해진 시간동안 thread의 실행을 멈춤(busy_waiting 방지)
	  . sleep_until() : 정해진 시간까지 thread의 실행을 멈춤(busy_waiting 방지)
	    무한루프 등으로 멈출 경우 CPU가 낭비됨
	  . yield() : 다른 쓰레드에게 실행 시간을 양보
	    - 자기가 할 일의 우선순위가 낮을 경우
	    - 작업을 끝내고 다음 작업의 도착을 기다리는 경우 : 루프를 돌면서
	      작업의 도착을 확인하고 yield를 해야 한다.

. 멀티 쓰레드 프로그래밍에서 중요한 사항
	- 올바른 결과가 나와야 한다.
	  . 무한루프에 빠지거나 프로그램이 오류로 종료하면 안 된다.
	- 멀티 쓰레드로 인한 성능향상이 커야 한다.
	  . 성능향상이 적으면 멀티 쓰레드 프로그래밍을 할 이유가 없다.


Data Race

. 원인
	- 공유 메모리를 여러 쓰레드에서 읽고 쓴다.
	- 읽고 쓰는 순서에 따라 실행 결과가 달라진다.
	  (프로그래머가 예상 못한 결과가 발생)
	- 이것을 Data Race라고 한다.
. Data Race의 정의
	- 복수 개의 쓰레드가 하나의 메모리에 동시 접근
	- 적어도 한 개는 Write

. 해결 방법
	- Data Race를 없애면 된다.
	- Lock과 Unlock을 사용한다.
	- 복수 개의 쓰레드가 동시에 접근할 수 없도록 한다.

. lock과 unlock
	- C++11 표준에 존재
	- mutex 클래스의 객체 생성 후 lock(), unlock() 메소드 호출
	- mutex 객체는 전역 변수로
	- 같은 객체 사이에서만 lock, unlock이 동작
	  . 다른 mutex 객체는 상대방을 모름
	- 서로 동시에 실행되도 괜찮은 Critical Section이 있다면 다른 mutex 객체로
	  보호하는 것이 성능이 좋음
	  . 같은 mutex 객체로 보호하면 동시에 실행이 안 됨