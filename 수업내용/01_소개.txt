CPU 논리 프로세서 (하이퍼쓰레드)
	. 가상 코어
	. 하나의 코어에서 두 개의 쓰레드 사용

컴퓨터
. 직렬 컴퓨터
	- 하나의 CPU(또는 Core)만을 갖는 컴퓨터
	- 듀얼코어가 대중화 되기 이전의 대부분의 컴퓨터
	- 현재 멸종

. 병렬 컴퓨터
	- 여러 개의 CPU(또는 Core)가 명령들을 실행하는 컴퓨터
	- 직렬 컴퓨터의 속도 제한을 극복하기 위해 제작

. 병렬 컴퓨터의 사용 목적
	- 여러 개의 작업을 보다 빨리 실행하기 위해서
	  . 여러 대의 컴퓨터를 사용해도 됨 -> 더 싸다
	- 하나의 작업을 보다 빨리 실행하기 위해서

. 병렬 프로그램
	- 기존의 프로그램을 병렬 컴퓨터에서 실행했을 경우 속도 증가는 0%
	- 동시에 여러 개의 명령 흐름이 실행되는 것을 가정하고 다시
	프로그래밍 해야 한다. -> 병렬 프로그래밍

. 병렬 프로그램의 특징
	- 실행된 프로세스의 내부 여러 곳이 동시에 실행됨
	- 병렬로 실행되는 객체(Context로 불림) 사이의 협업이 필수
	- 크게 공유메모리(Shared Memory) 모델과 메시지 패싱(Message Passing) 모델이 있음
	- 우리가 다루는 것은 공유 메모리 모델

. 병렬 프로그램 요구사항 : 정확성과 성능
	- 여러 흐름(Context)에서 동시 다발적으로 호출해도 문제 없이 실행되는
	알고리즘이 필요.
	  . 오류가 발생하면 모든 것이 의미 없음
	- Context의 증가에 따른 성능 향상이 높아야 한다.
	  . 기존의 직렬 프로그램보다 느려질 수 있다.


멀티쓰레드 프로그래밍
	- 현재 운영체제에서 병렬 프로그래밍의 (유일한) 구현 수단
	- 하나의 프로세스 안에서 여러 개의 쓰레드를 실행 시켜 병렬성을 얻는 프로그래밍 방법
	- Windows, Linux, Android, iOS에서 기본으로 제공하는 유일한 병렬 프로그래밍 API
	  . HW와 운영체제가 직접 지원하는 것은 이것 뿐
	  . 다른 API로는 GPGPU가 있음.

. 프로세스
	- 운영체제는 사용자의 프로그램을 프로세스 단위로 관리한다.
	- 실행파일의 실행 -> 운영체제가 파일 내용을 메모리에 복사 후 시작 주소로 점프하는 것.
	  . 읽어 들일 때 여러 가지 초기화가 필요하다.
	- 시분할 운영체제는 여러 프로세스를 고속으로 번갈아 가면서 실행한다.
	  . 실행중인 프로세스의 상태를 강제로 준비(Ready)로 변경 가능
	- 프로세스의 메모리 구조는 다음과 같다
	  . Code : 실행될 명령어가 들어가는 구역
	  . Data : 전역변수가 들어가는 구역
	  . Stack : 지역변수와 함수 리턴 주소가 들어가는 구역
	  . Heap : malloc이나 new로 할당 받은 메모리가 들어가는 구역
	  . PCB : Process Control Block

. 프로세스와 쓰레드
	- 프로세스는 초기에 하나의 시작 쓰레드를 가짐
	- 쓰레드는 다른 쓰레드를 만들 수 있다.
	- 쓰레드 생성은 프로그래머가 지시한다.
	- 모든 쓰레드는 자신 고유의 Stack을 가지고 있고, Data와 Code를 공유한다.
	- 쓰레드는 CPU에서 하드웨어적으로 관리된다. (x86)

. 프로세스에 비한 쓰레드의 장점
	- 생성 Overhead가 적다
	- Context Switch Overhead가 적다.
	  . Virtual memory (TLB 교체 오버헤드)
	- 쓰레드간의 통신이 간단하다.
. 쓰레드의 단점
	- 하나의 쓰레드에서 발생한 문제가 전체 프로세스를 멈추게 한다.
	- 디버깅이 어렵다.

. 멀티 쓰레드의 사용 목적
	- 멀티 코어 CPU에서의 프로그램 성능향상
	- 멀티 CPU 컴퓨터에서의 프로그램 성능 향상
	- (아님) 분산 컴퓨터에서의 프로그램 성능 향상
	  . 컴퓨터 여러 대를 네트워크로 연결한 것이 분산 컴퓨터임
	- (아님) 싱글 코어(CPU) 컴퓨터 환경에서의 프로그램 성능향상
	  . 그렇게 느껴진다면 원본 프로그램이 문제가 있는 것
	- (아님) 프로그램을 모듈화 해서 알아보기 쉽게

멀티코어 CPU
. 한 개 이상의 코어로 구성된 CPU를 뜻함.


멀티코어 프로세서

. Intel과 ARM에서 멀티코어 프로세서를 만드는 이유
	- CPU의 성능을 올려야 한다.
	  . 안 그러면 아무도 안 산다.
	- 클럭 속도를 높일 수 없다.
	  . 발열 문제(물리법칙)
	- 클럭 속도 말고 CPU의 속도를 올리는 법
	  . 아키텍처 개선 : 캐시, 파이프라인, 예측 분기, 동적수행
	- 남은 방법
	  . 멀티코어

. 멀티코어 프로세서의 코어
	- ALU + Register + CU + Cache
	- 그냥 CPU와 똑같다.

. 왜 이렇게 늦게 나왔는가
	- 프로그래머가 싫어하기 때문
	  . 프로그램을 다시 작성하지 않으면 성능향상 0
	  . 전혀 다른 알고리즘들을 사용해야 한다.
	  . 디버깅이 더럽게 어렵다.
	- 옛날부터 있었다.

. 현재
	- 4 Core가 대세
	  . 2017년부터 코어 개수 급속 증가.

. 멀티코어 이전의 병렬 컴퓨터
	- SMP(Symmetric Multi Processor) Computer
	  . 컴퓨터 안에 CPU가 여러 개 꽂혀 있고, 각 CPU는 동등한 입장에서 명령을 처리한다.
	  . 1962년 첫 시제품

. 프로그래밍 방법이 바뀌어야 한다
	- 기존의 프로그램을 듀얼 코어 CPU에서 실행하였다.
	  속도 향상은 얼마인가? -> 0%
	- 멀티쓰레드 프로그래밍을 해야 한다.
	- 좋은 멀티쓰레드 프로그래밍이란?
	  . Core의 개수에 비례해서 실행속도 증가


멀티쓰레드 프로그래밍

. 프로그래밍 방법
	- C++ 프로그래밍 언어에 멀티쓰레드 라이브러리가 표준으로 존재
	- 2011년도에 새로운 C++ 언어의 표준으로 C++11이 공표되었음
	- 표준 C++ 언어를 지원하는 컴파일러라면 하드웨어나 운영체제에
	  관계 없이 사용

. 자기 자신
	- this_thread : 주의)name_space임
	- this_thread의 API
	  . get_id() : 자기 자신의 thread_id
	  . sleep_for() : 정해진 시간동안 thread의 실행을 멈춤(busy_waiting 방지)
	  . sleep_until() : 정해진 시간까지 thread의 실행을 멈춤(busy_waiting 방지)
	    무한루프 등으로 멈출 경우 CPU가 낭비됨
	  . yield() : 다른 쓰레드에게 실행 시간을 양보
	    - 자기가 할 일의 우선순위가 낮을 경우
	    - 작업을 끝내고 다음 작업의 도착을 기다리는 경우 : 루프를 돌면서
	      작업의 도착을 확인하고 yield를 해야 한다.

. 멀티 쓰레드 프로그래밍에서 중요한 사항
	- 올바른 결과가 나와야 한다.
	  . 무한루프에 빠지거나 프로그램이 오류로 종료하면 안 된다.
	- 멀티 쓰레드로 인한 성능향상이 커야 한다.
	  . 성능향상이 적으면 멀티 쓰레드 프로그래밍을 할 이유가 없다.


Data Race

. 원인
	- 공유 메모리를 여러 쓰레드에서 읽고 쓴다.
	- 읽고 쓰는 순서에 따라 실행 결과가 달라진다.
	  (프로그래머가 예상 못한 결과가 발생)
	- 이것을 Data Race라고 한다.
. Data Race의 정의
	- 복수 개의 쓰레드가 하나의 메모리에 동시 접근
	- 적어도 한 개는 Write

. 해결 방법
	- Data Race를 없애면 된다.
	- Lock과 Unlock을 사용한다.
	- 복수 개의 쓰레드가 동시에 접근할 수 없도록 한다.

. lock과 unlock
	- C++11 표준에 존재
	- mutex 클래스의 객체 생성 후 lock(), unlock() 메소드 호출
	- mutex 객체는 전역 변수로
	- 같은 객체 사이에서만 lock, unlock이 동작
	  . 다른 mutex 객체는 상대방을 모름
	- 서로 동시에 실행되도 괜찮은 Critical Section이 있다면 다른 mutex 객체로
	  보호하는 것이 성능이 좋음
	  . 같은 mutex 객체로 보호하면 동시에 실행이 안 됨

Mutex
- 한 번에 하나의 쓰레드만 실행 시킴
	. 병렬성 감소, 병렬실행으로 인한 성능향상 감소
- Lock을 얻지 못하면 Queue에 순서를 저장하고 스핀
	. Lock() 메소드 자체의 오버헤드
- 심각한 성능 저하

Atomic (C++11)
- 모든 atomic 연산은 다른 atomic 연산과 동시에 수행되지 않는다.
- atomic 연산끼리의 실행 순서는 프로그래밍 순서를 따르고 절대 바뀌지 않는다.
	. C++11 아닌 일반적인 정의 : atomic 연산이 아닌 일반적인 연산과도
	  실행 순서가 바뀌지 않는다.
	. 그러나 C++11에서는 지켜지지 않는다.
- 모든 atomic 연산의 실행 순서는 모든 쓰레드에서 동일하게 관찰된다.
	. atomic 연산이 아니면 다르게 관측될 수도 있다.
- lock add 명령어를 사용한다.
	. 소프트웨어적 오버헤드는 없으나 하드웨어적 오버헤드가 있다.
- atomic의 한계
	. sum = sum + 2와 sum += 2는 다르다.
	. sum = sum + 2 연산은 원자적이지 않다.
- volatile과의 차이는?
	. volatile은 컴파일러 레벨에서 대응이 끝난다.
	. atomic은 CPU에 lock을 걸도록 하기 때문에 CPU레벨에까지 영향을 미친다.
- mutex보다는 빠르다

sum을 local 변수로 해야 하는가?
- 배열을 사용한다면? lock 없이도 결과를 구할 수 있다.
- Cache Thrasing
	. Invalidation Pingpong
	. Core 0이 Sum[0]에 접근할 때 Sum 전체를 Core 0의 캐시에 올린다.
	. Core 1이 Sum[1]에 접근할 때 Sum 전체를 Core 1의 캐시에 올린다.
	. 같은 메모리는 여러 코어의 캐시에 동시에 올라갈 수 없도록 제한되어 있다.
	. 즉 Core 0의 캐시 내용을 Core 1로 이동시킨다. -> 오버헤드가 심하다.
- Cache Thrashing 해결
	. 쓰레드마다 서로 다른 cache line을 사용하도록 한다.
	. C++ alignas 키워드 사용 (변수를 사용할 때 크기를 alignas만큼 키워서 할당해라)

병렬 컴퓨팅이란?
- 여러 개의 코어를 사용하여 프로그램의 성능을 높힌다.


멀티쓰레드 프로그래밍의 사용처
- 과학 기술 계산
- 멀티미디어
	. Encoding & Decoding
	. 멀티쓰레드의 구현이 매우 쉬움 (독립된 장면들 - keyframe 단위)
- 게임
	. 온라인 게임 서버 (1997년부터)
	. 3D 게임 엔진 (2000년대 중반 부터)

멀티쓰레드 프로그래밍의 종류
- Heterogeneous 멀티쓰레딩
	. 쓰레드마다 맡은 역할이 다르다.
	. 다른 Code Part를 실행
	. 쓰레드간의 Load Balancing이 힘들다.
	. 병렬성이 제한된다.
- Homogeneous 멀티쓰레딩
	. Data/Event Driven 프로그래밍
	. 모든 쓰레드는 Symmetric하다.
	  - Available한 순서대로 다음 작업을 처리한다.
	  - 게임서버에 배틀 쓰레드, 힐 쓰레드 이런거 없다.
	. 자동적인 load balancing, 제한없는 병렬성
	. 작업 분배 Queue를 비롯한 일반적인 병렬 자료구조 필요
	. 모든 쓰레드가 Data Race에 노출되어 있다.

MMORPG Game Server
- Massively Multiplayer Online Roll Playing Game
- 한 개의 서버 프로세스에 5000명 이상의 사용자가 동시 접속해서 게임 실행
- 게임 서버는 가상 환경을 시뮬레이션하는 네트워크 이벤트 시뮬레이터
	. 5000명 플레이어 (소켓)
	. 수십만 몬스터 (AI)
	. 20km x 20km 월드 (충돌체크, 길찾기)
- Windows에서 제공하는 멀티쓰레드+네트워크 I/O API인 IOCP 사용
	. 일반적인 Select() 함수로는 몇천개의 socket을 관리할 수 없음.
	. socket 하나당 하나의 쓰레드는 운영체제의 과부하
	. Linux나 iOS는 epoll 또는 kqueue 사용
	  2019년 Linux io-uring 추가
- Time Consuming 작업 및 Blocking 작업들의 재배치
	. Throughput과 함께 response time도 중요
	. 따라서 라운드 로빈 알고리즘 사용
- Homogemeous Multithreading
	. Worker Thread의 pool 사용
	. socket을 통해 packet이 올 때 마다, OS가 thread pool의 thread르
	  하나 깨워서 packet의 처리를 맡김.
	. HW Core 개수 1.5배의 worker threads
	  - I/O 블로킹 고려
	  - 정해져 있지 않음. 벤치마킹을 통해 조절
	. Network 데이터 처리 뿐만 아니라 AI 루틴도 Worker Thread에서 처리
	  - 모든 time consuming 작업은 병렬로 처리
- 멀티쓰레드 트릭 #1 : Database Query
	. 문제 : Database 쿼리는 쓰레드의 Blocking을 초래
	. 해결 : Blocking 전용 쓰레드를 따로 두어서, 작업 전달
- 멀티쓰레드 트릭 #2 : NPC AI
	. 문제 : NPC가 너무 많다
	. 해결 : Timer Thread를 사용하여, active한 NPC의 active event만 처리
- Worst Case Tuning
	. 게임서버의 목적 : 동접을 높히는 것
	. 평상시의 CPU낭비 OK, 최대 부하일 때 잘 버티도록 프로그램 설계
- 컨테이너 자료구조를 사용한 객체간 동기화
	. Queue, Priority Queue, Set
	  - 그냥 쓰면 안된다. 멀티쓰레드랑 관계 없는 컨테이너
	. Custom 자료구조
	  - 1 write/multi reader queue
- Thread & Cache Affinity
	. 쓰레드가 코어를 바꿔 가면서 실행되면 성능에 좋지 않다.
	. 쓰레드가 사용할 코어를 지정해 줄 수 있다.
	. 하지 말자.
