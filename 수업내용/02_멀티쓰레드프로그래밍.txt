1. Data Race로 인한 오동작을 해결하여야 한다.
2 - 1. Data Race를 없애자
	. mutex
	. 성능 저하
	. Data Race를 줄이자
	. 알고리즘 재작성
	. 너무 어렵다
2 - 2. Data Race를 고려하자
	. 쉬워 보이지만 더럽게 어렵다


컴파일러의 사기를 피하는 방법
- lock/unlock을 사용한다.
- volatile을 사용하면 된다.
	. 반드시 메모리를 읽고 쓴다.
	. 변수를 레지스터에 할당하지 않는다.
	. 읽고 쓰는 순서를 지킨다.

volatile 사용법
- volatile int* a;
	. *a = 1;	// volatile 적용
	. a = b;	// 컴파일러의 최적화 대상
- int* volatile a;
	. *a = 1;	// 컴파일러의 최적화 대상
	. a = b;	// volatile 적용

정리
- 여러 개의 쓰레드가 공유하는 변수는 volatile을 사용해야 한다.
- volatile을 사용하면 컴파일러는 프로그래머가 지시한 대로 메모리에 접근한다.
	. volatile이 없으면 컴파일러는 싱글쓰레드를 기준으로 프로그램을 최적화한다.
- 하지만 CPU는 volatile을 모른다.



상호 배제
- 멀티 쓰레드 프로그램에서의 문제는 하나의 자원을 여러 쓰레드에서 동시에
  사용해서 생기는 경우가 대부분
- 해결책
	. 공유 자원을 업데이트 하는 부분은 한 번에 하나의 쓰레드에서만
	  실행할 수 있도록 하자.
	. 이것을 상호 배제(mutual exclusion)라 부른다.

피터슨 알고리즘
- 맞는 알고리즘이다
- 빈번한 메모리 참조로 인한 성능 문제
- 실제 컴퓨터에서 오동작을 일으킨다

정리
- 멀티쓰레드에서 프로그램의 이상 동작
	. C언어 자체의 문제
	. 컴파일러의 문제가 아님
	. volatile로 해결
- volatile을 사용함에도 문제가 있음
	. 어셈블리로 확인해 봐도 문제 없음
- mutex를 사용할 경우의 성능 저하
	. custom하게 만든 simple한 lock도 성능상의 문제가 있음