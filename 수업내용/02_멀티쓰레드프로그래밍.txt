1. Data Race로 인한 오동작을 해결하여야 한다.
2 - 1. Data Race를 없애자
	. mutex
	. 성능 저하
	. Data Race를 줄이자
	. 알고리즘 재작성
	. 너무 어렵다
2 - 2. Data Race를 고려하자
	. 쉬워 보이지만 더럽게 어렵다

컴파일러 단의 문제
컴파일러의 사기를 피하는 방법
- lock/unlock을 사용한다.
- volatile을 사용하면 된다.
	. 반드시 메모리를 읽고 쓴다.
	. 변수를 레지스터에 할당하지 않는다.
	. 읽고 쓰는 순서를 지킨다.

volatile 사용법
- volatile int* a;
	. *a = 1;	// volatile 적용
	. a = b;	// 컴파일러의 최적화 대상
- int* volatile a;
	. *a = 1;	// 컴파일러의 최적화 대상
	. a = b;	// volatile 적용

정리
- 여러 개의 쓰레드가 공유하는 변수는 volatile을 사용해야 한다.
- volatile을 사용하면 컴파일러는 프로그래머가 지시한 대로 메모리에 접근한다.
	. volatile이 없으면 컴파일러는 '싱글쓰레드를 기준'으로 프로그램을 최적화한다.
- 하지만 CPU는 volatile을 모른다.



상호 배제
- 멀티 쓰레드 프로그램에서의 문제는 하나의 자원을 여러 쓰레드에서 동시에
  사용해서 생기는 경우가 대부분
- 해결책
	. 공유 자원을 업데이트 하는 부분은 한 번에 하나의 쓰레드에서만
	  실행할 수 있도록 하자.
	. 이것을 상호 배제(mutual exclusion)라 부른다.

임계 영역
- Critical Section
- 프로그램 중 상호배제로 보호받고 있는 구간
- 오직 하나의 쓰레드만 실행할 수 있음
구현
- Lock, Unlock을 사용해서 Lock과 unlock 사이에 임계 영역을 둔다.
- lock은 다른 쓰레드가 lock을 통과했고 unlock을 하기 전이라면 unlock을 실행할 때까지
  프로그램의 실행을 멈춘다.

피터슨 알고리즘
- 맞는 알고리즘이다
- 빈번한 메모리 참조로 인한 성능 문제
- 실제 컴퓨터에서 오동작을 일으킨다

정리
- 멀티쓰레드에서 프로그램의 이상 동작
	. C언어 자체의 문제
	. 컴파일러의 문제가 아님
	. volatile로 해결
- volatile을 사용함에도 문제가 있음
	. 어셈블리로 확인해 봐도 문제 없음
- mutex를 사용할 경우의 성능 저하
	. custom하게 만든 simple한 lock도 성능상의 문제가 있음