1. Data Race로 인한 오동작을 해결하여야 한다.
2 - 1. Data Race를 없애자
	. mutex
	. 성능 저하
	. Data Race를 줄이자
	. 알고리즘 재작성
	. 너무 어렵다
2 - 2. Data Race를 고려하자
	. 쉬워 보이지만 더럽게 어렵다


컴파일러의 사기를 피하는 방법
- lock/unlock을 사용한다.
- volatile을 사용하면 된다.
	. 반드시 메모리를 읽고 쓴다.
	. 변수를 레지스터에 할당하지 않는다.
	. 읽고 쓰는 순서를 지킨다.

volatile 사용법
- volatile int* a;
	. *a = 1;	// volatile 적용
	. a = b;	// 컴파일러의 최적화 대상
- int* volatile a;
	. *a = 1;	// 컴파일러의 최적화 대상
	. a = b;	// volatile 적용

정리
- 여러 개의 쓰레드가 공유하는 변수는 volatile을 사용해야 한다.
- volatile을 사용하면 컴파일러는 프로그래머가 지시한 대로 메모리에 접근한다.
	. volatile이 없으면 컴파일러는 싱글쓰레드를 기준으로 프로그램을 최적화한다.
- 하지만 CPU는 volatile을 모른다.