멀티쓰레드 프로그래밍 가이드
- Homogeneous 멀티쓰레드 프로그래밍
- Locking의 회피
- 공유 자료 구조의 사용

메모리 일관성
지금까지의 프로그램은 공유 메모리에 대한 접근(쓰기/읽기)은 atomic하다고 가정하고 있다.
- 정말 그런가?

atomic
- 메모리의 접근이 순간적으로 행해지며, 서로 겹쳐지지 않는다.
- 실행결과 순서가 정해지면, 모든 쓰레드에서 같은 순서로 보인다.

- PC에서의 메모리 접근은 atomic이 아니다.
- 메모리에 쓴 순서대로 메모리가 수정되지 않는다.
	. 정확히는 메모리에 쓴 순서대로 메모리의 내용이 관측되지 않는다.

- 피터슨 알고리즘에서 역전
	. Write가 되기 전에 Read를 한다.
	. _asm mfence 명령어를 통해 실행 순서를 강제로 맞춰 줄 수 있다.

메모리 접근이 atomic하지 않은 이유는?
- CPU는 사기를 친다
	. Line Based Cache Sharing
	. Out of Order Execution (비순차적 명령어 처리)
	. Write Buffering
	. 사기를 치지 않으면 실행속도가 느려진다.
- CPU는 프로그램을 순차적으로 실행하는 척만 한다.
	. 이를 보조해 주는 특수한 HW가 존재한다.
	. 싱글코어에서는 절대로 들키지 않는다.

Out of Order Execution
- CPU는 관계가 없는 명령어끼리는 순서를 바꿔 명령을 실행할 수 있다.
- 싱글쓰레드에서는 관계가 없지만 멀티쓰레드에서는 관계가 있을 수 있다.

Write Buffering

문제는 메모리
- 읽고/쓰는 기계어가 순서대로 실행되지 않는다.
	. volatile로도 해결되지 않는다
	  - volatile 키워드는 기계어로 번역되지 않는다.
	. 읽기와 쓰기는 시간이 많이 걸리므로
	  - CPU의 입장에서 보면
	  - 실제 영향이 발휘되는 시간은 상대 Core에 따라 다르다.
	. 옆의 프로세서(Core)에서 

thread a		thread b
write x 1		write x 2
read x w		read x 1


- 메모리 변경 순서가 뒤바뀔 확률은?
- atomic_thread_fence()로 오류를 없애 보자
- atomic_int로 극복해 보자.

Cache Line Size Boundary
- 캐시를 읽을 때 캐시에 없으면 메모리에서 읽어 캐시에 넣는다.
- 이 때 한 바이트만 읽는 것이 아니라 64바이트 캐시 라인 전체를 읽어 넣는다.
- 그래야 메모리 낭비도 줄고 캐시 히트 확률도 올라간다.(공간적 지역성)
- DDR 메모리 특징은 한 메모리를 읽는 속도는 느리지만 그 다음 바이트를 읽는 속도는 매우 빠르다.

- 우리는 4바이트 메모리가 두 캐시 라인에 2바이트씩 걸치도록 만들었다.

- 중간값
	. Write시 최종 값과 초기값이 아닌 다른 값이 도중에 메모리에 써지는 현상
- 이유는?
	. Cache Line Size Boundary
- 대책
	. 포인터를 믿지 마라
	. Byte밖에 믿을 수 없다.
	. 포인터가 아닌 변수는 Visual C++가 잘 해준다.

메모리 일관성
- 무모순성 (Consistency)이라고 불리운다
- Memory Consistency 또는 Memory Ordering이라고 불린다.
- 강한 모델과 약한 모델이 있고 각각 허용되는 결과들을 제한하는 정도가 다르다.
- 실제 컴퓨터가 제공하는 모델과 프로그래밍에 사용되는 모델을 동기화 명령을 사용해서 일치시켜야 한다.

정리
- 멀티쓰레드에서의 공유 메모리
	. 다른 코어에서 보았을 때 업데이트 순서가 다를 수 있다. (쓰는 쪽과 읽는 쪽 둘 다의 문제)
	. 메모리의 내용이 한 순간에 업데이트 되지 않을 때도 있다.
- 일반적인 프로그래밍 방식으로는 멀티쓰레드에서 안정적으로 돌아가는 프로그램을 만들 수 없다.

어떻게 할 것인가?
- 위의 상황을 감안하고 프로그램 작성?
	. 프로그래밍이 너무 어렵다.
	. 피터슨 알고리즘도 동작하지 않는다.
- 강제로 원하는 결과를 얻도록 한다.
	. 모든 메모리 접근을 <mytex>로 막으면 가능
	  - 성능 저하
	. atomic_thread_fence() 명령어를 적절한 위치에 추가
	  - 찾은 위치가 완벽하다는 보장은?
- 해결 방향
	. 꼭 필요한 곳에 atomic_thread_fence() 사용
	. 공유 변수로 atomic한 메모리 사용
	  - 컴파일러가 적절한 위치에 atomic_thread_fence를 넣어줌

희망
- 메모리에 대한 쓰기는 언젠가는 완료된다.
- 자기 자신의 프로그램 실행 순서는 지켜진다.
- 캐시의 일관성은 지켜진다.
	. 한 번 지워졌던 값이 다시 살아나지는 않는다.
	. 언젠가는 모든 코어가 동일한 값을 본다.
- 캐시라인 내부의 읽기/쓰기는 중간 값을 만들지 않는다.
- CPU의 여러 삽질에도 불구하고 atomic memory를 구현할 수 있다.
	. mutex나 fence없이 SW적인 방법 만으로도 가능
	. CPU에 특수 명령어로 구현되어 있음
	  - C++ 11에서 사용

atomic
- 접근(메모리는 read, wrote)의 절대 순서가 모든 쓰레드에서 지켜지는 자료구조
- 프로그래머가 필요로 하는 바로 그 자료구조
- 싱글코어에서는 모든 메모리가 atomic memory이다.
- load(), store()를 사용해야 하지만 = 연산자 역시 오버로딩 되어 있다.
- C++에서는 atomic한 변수를 다룰 때 항상 atomic하게 동작하지 않는다.
  다른 일반적인 변수와의 연산 시 non atomic하게 동작할 수 있다.

atomic memory만 있으면 되는가?
- NO
- 실제 상용 프로그램을 int, long, float같은 기본 data type만으로 작성할 수 있는가?
	. 실제 프로그램은 기본 data type을 사용하여 다양한 자료구조를 구축하여 사용한다.
	  - queue, stack, binary tree, vector
- atomic memory를 사용하여 만든 자료구조가 atomic한가?
	. NO
- 효율적인 atomic 자료구조가 필요하다.
	. 일반 자료구조에 lock을 추가하면?
	  - 너무 느리다
	. STL은?
	  - CRASH
	. STL + LOCK은?
	  - 너무 느리다.


Non-Blocking
블로킹(Blocking)
- 다른 쓰레드의 진행상태에 따라 진행이 막힐 수 있음
	. ex) while(lock != 0)
- 멀티쓰레드의 bottle neck이 생긴다.
- lock을 사용하면 블로킹

논블로킹(Non-blocking)
- 다른 쓰레드가 어떤 삽질을 하고 있던 상관 없이 진행

블로킹 알고리즘의 문제
- 성능 저하
- Priority Inversion
	. Lock을 공유하는 덜 중요한 작업들이 중요한 작업의 실행을 막는 현상
	. Reader/Write Problem에서 많이 발생
- Convoying
	. Lock을 얻은 쓰레드가 스케줄링에서 제외된 경우, Lock을 기다리는
	  모든 쓰레드가 공회전
	. Core보다 많은 수의 Thread를 생성했을 경우 자주 발생
	. C++의 mutex는 lock을 획득 중인 쓰레드가 스케줄링에서 제외되지 않도록 최적화되어 있다.
-> 성능이 낮아도 Non-Blocking이 필요할 수 있다.

다른 쓰레드의 완료를 기다리는 작업이 있다면 뮤텍스나 다를 바 없다.

논블로킹의 등급
- 무대기(wait-free)
	. 모든 메소드가 정해진 유한한 단계에 실행을 끝마침
	. 멈춤 없는 프로그램 실행
- 무잠금(lock-free)
	. 항상, 적어도 한 개의 메소드가 유한한 단계에 실행을 끝마침
	  - 여러 쓰레드가 충돌할 경우 그 여파로 느려질 수는 있지만 적어도 한 개는 유한한 단계에 끝난다.
	  - 블로킹이 아니냐? mutex를 걸면 이렇게 되지않느냐..
	  - '최소'한의 조건이다. 대부분의 경우는 적어도 두개 세개 네개씩 실행된다.
	. 무대기이면 무잠금이다.
	. 기아(starvation)을 유발하기도 한다.
	  - 충돌 시 특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태
	  - Convoying하고는 다르다.
	. 성능을 위해 무대기 대신 무잠금을 선택하기도 한다.

->
	. Lock을 사용하지 않고
	. 다른 쓰레드가 어떠한 행동을 하기를 기다리는 것 없이
	. 자료구조의 접근을 atomic하게 해주는 알고리즘의 등급
- 멀티 쓰레드 프로그래밍에서 쓰레드 사이의 효율적인 자료 교환과 협업을 위해서는 Non-blocking 자료 구조가 필요하다.