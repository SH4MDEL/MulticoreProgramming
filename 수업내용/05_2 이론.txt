합의 객체 (Consensus Object)
- Non-blocking 알고리즘을 만들기 위한 객체

합의수 (Consensus Number)
- Non-blocking 알고리즘을 만드는 능력

만능성 (Universality)
- 모든 알고리즘을 멀티 쓰레드 무대기로 구현할 수 있는가


복습
- 우리가 사용하고 있는 컴퓨터의 메모리는 atomic하지 않다.
- 하지만 우리는 atomic하게 사용할 수 있다.
	. atomic<T>를 사용해서 자료구조 T를 atomic하게 사용하도록 컴파일한다.
	. 적절한 위치에 atomic_thread_fence를 추가한다.

- atomic<point> pos
	. 돌아는 간다. 쓰지 말자 (내부적으로 global mutex를 사용해서 구현)


동기화
- 자료구조의 동작을 atomic하게 구현하는 것

합의
- 새로운 동기화 연산을 제공하는 가상의 객체
- 동기화 연산 : Ttype_t decide(Type_t value)
- 동작
	. n개의 쓰레드가 decide를 호출한다.
	. 각각의 쓰레드는 한번 이하로만 호출한다.
	. decide는 모든 호출에 대해 같은 값을 반환한다.
	. decide가 반환하는 값은 전달된 value 중 하나이다.
	. atomic하고 wait-free로 동작한다.
- 의미
	. 모든 쓰레드가 같은 결론을 얻는 방법
	. decide()를 호출하면 모든 쓰레드가 wait-free로 같은 결론을 얻는다.
	. 여러 경쟁 쓰레드들 중 하나를 선택하고, 누가 선택되었는지 모든 쓰레드가 알게 한다.


합의수
정의
- 동기화 연산을 제공하는 클래스 C가 있을 때
- 클래스 C와 atomic 메모리를 여러 개 사용해서 n개의 쓰레드에 대한 합의 객체를 구현할 수 있다.
  -> 클래스 C가 N-쓰레드 합의 문제를 해결한다(solve)고 한다.
- 클래스 C의 합의 수(Consensus Number)
	. C를 이용해서 해결 가능한 N-쓰레드 합의 문제 중 최대의 N을 말한다.
	  만약 최대 N이 존재하지 않는다면 그 클래스의 합의수를 무한하다(Infinite)고 한다.

- 문제 단순화
	. 쓰레드 2개 : A, B
	. 각각 0과 1로 합의 시도
	. C는 합의 객체 (atomic 메모리 read/write로만 구현)
	. return값은 모두 0이던가, 모두 1이어야 한다.

- 쓰레드는 합의를 이룰 때 까지 계산하면서 이동(move)한다.
	. wait-free이므로 언젠가는 이동이 끝난다.
	  - A와 B의 decide 호출이 완료된다.
	  - 이 시점에서는 return값이 1 또는 0으로 결정되어 있다.
	. 이동할 때만. 전체 실행 상태가 변경될 수 있다.
	  - 상태: return값의 결정 영향을 미치는 메모리나 레지스터의 값
	. 이동이 아니면 상태가 변경되지 않는다.
	  - 이동 결과에 의해서만 상태가 변경된다.
- 초기상태: 아무런 이동이 없는 경우
- 최종상태: 모든 쓰레드들이 이동을 마친 상태(프로토콜의 leaf)
	. decide 메소드가 결정된 값을 리턴한다.
- 일가(univalent) 상태: 앞으로 어떠한 이동을 하더라도 결정 값이 변화가 없는 경우
- 이가(bivalent) 상태: 최종 결정 값이 결정되지 않은 상태
	. 모든 트리의 상태는 일가 상태 또는 이가 상태
- 임계(critical) 상태
	. 현재 상태가 이가이다.
	. 다음의 이동으로 무조건 일가 상태가 된다.

보조 정리
- 모든 2-쓰레드 합의 프로토콜의 초기상태는 이가이다.
	. A가 0, B가 1을 합의시킬 경우
	. A만 실행하면 0, B만 실행하면 1을 결정해야 한다.
	  -> 실행 순서에 따라 결과가 바뀐다.
	  -> 따라서 일가가 아니다.
- 모든 2-쓰레드 합의 프로토콜은 초기상태가 이가이다.
- 모든 무대기 합의 프로토콜은 임계 상태가 반드시 존재한다.

명제: atomic 메모리로 2쓰레드 합의 문제를 해결할 수 있다.
- atomic 메모리로 구현했다고 가정하면
- decide를 알고리즘으로 구현했고 protocol을 그릴 수 있따.
- 임계상태가 반드시 존재하며, 그 때 가능한 이동 시나리오는
	. A: read, B: write or read
	. A: write r0, B: wirte r1 (r0 != r1)
	. A: write r, B write r

- A: read, B: write or read
	. A가 읽었는지 안 읽었는지 모르는 채로 B는 0일지 아닌지를 구분해야 한다.
- A: write r0, B: wirte r1 (r0 != r1)
	. 어느 순서로 썼는지 구분할 수 없다.
- A: write r, B write r
	. A가 썼는지 안 썼는지 알 수 없는 채로 B는 0과 1을 결정해야 하는 경우가 생긴다.
	  - A의 write r을 B의 write r이 덮어 쓴 경우와 아닌 경우를 B는 구분할 수 없다.
=> 임계 노드가 존재할 수 없다.

FIFO QUEUE
- atomic 메모리로 2쓰레드 합의 객체를 구현할 수 없다면 무엇이 필요한가?
- Queue 객체가 있으면 해결이 가능한가?
- 가상의 큐를 가정하자.
	. 2개의 쓰레드에서 동시에 deque를 했을 때 atomic하고 wait-free하게 동작하는 queue


다중 대입 객체
- 그렇다면 N개 쓰레드의 합의 객체를 구현할 수 있는 합의수 N의 동기화 객체가 존재하는가?
-> 존재한다.
- 다중 대입 객체: 배열로 구성되며 복수의 원소를 atomic하게 변경할 수 있는 객체

- 원자적인 (n, n(n+1)/2) - 대입 객체는 최소 n의 합의수를 가진다.
- 따라서 대입 객체들을 HW적으로 지원하면 합의문제를 무대기로 해결할 수 있다.
	. HW구현 비용이 매우 크다.
	. 대안은? RMW

RMW (Read-Modify-Write)
- 하드웨어가 지원하는 동기화 연산의 한 종류
- 특수 명령어가 반드시 필요(Wait-Free가 되기 위해서는)
메소드 M은 함수 f에 대한 RMW이다.
	. 메소드 M이 원자적으로 현재 메모리의 값을 v에서 f(v)로 바꾸고 원래 값 v를 반환한다.