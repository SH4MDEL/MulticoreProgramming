합의 객체 (Consensus Object)
- Non-blocking 알고리즘을 만들기 위한 객체

합의수 (Consensus Number)
- Non-blocking 알고리즘을 만드는 능력

만능성 (Universality)
- 모든 알고리즘을 멀티 쓰레드 무대기로 구현할 수 있는가


복습
- 우리가 사용하고 있는 컴퓨터의 메모리는 atomic하지 않다.
- 하지만 우리는 atomic하게 사용할 수 있다.
	. atomic<T>를 사용해서 자료구조 T를 atomic하게 사용하도록 컴파일한다.
	. 적절한 위치에 atomic_thread_fence를 추가한다.

- atomic<int> a;
	. a에 대한 모든 연산을 atomic으로 수행하며, wait-free로 수행된다.
- atomic<vector> v;
	. 컴파일 에러. 복잡한 자료구조는 atomic하게 변경할 수 없다.
- atomic<point> pos (int x, y, z)
	. 돌아는 간다. 쓰지 말자 (내부적으로 global mutex를 사용해서 구현)

- atomic한 복잡한 자료구조가 필요하면?
	. vector, tree, hash_table, priorty_queue
- 적절한 동기화기법을 사용해서 Non-blocking으로 변환해서 사용해야 한다.


동기화
- 자료구조의 동작을 atomic하게 구현하는 것
- 동기화를 구현하기 위해서는 기본 동기화 연산들을 사용해야 한다.
	. ex) atomic_load(), atomic_store()
- 이 기본 동기화 연산들은 무대기(wait-free) 혹은 무잠금(lock-free)이어야 한다.
	. 아니면 무대기나 무잠금 동기화를 구현할 수 없다.

합의
- 새로운 동기화 연산을 제공하는 가상의 객체
- 동기화 연산 : Ttype_t decide(Type_t value)
- 동작
	. n개의 쓰레드가 decide를 호출한다.
	. 각각의 쓰레드는 한번 이하로만 호출한다.
	. decide는 모든 호출에 대해 같은 값을 반환한다.
	. decide가 반환하는 값은 전달된 value 중 하나이다.
	. atomic하고 wait-free로 동작한다.
- 의미
	. 모든 쓰레드가 같은 결론을 얻는 방법
	. decide()를 호출하면 모든 쓰레드가 wait-free로 같은 결론을 얻는다.
	. 여러 경쟁 쓰레드들 중 하나를 선택하고, 누가 선택되었는지 모든 쓰레드가 알게 한다.


합의수
정의
- 동기화 연산을 제공하는 클래스 C가 있을 때
- 클래스 C와 atomic 메모리를 여러 개 사용해서 n개의 쓰레드에 대한 합의 객체를 구현할 수 있다.
  -> 클래스 C가 N-쓰레드 합의 문제를 해결한다(solve)고 한다.
- 클래스 C의 합의 수(Consensus Number)
	. C를 이용해서 해결 가능한 N-쓰레드 합의 문제 중 최대의 N을 말한다.
	  만약 최대 N이 존재하지 않는다면 그 클래스의 합의수를 무한하다(Infinite)고 한다.
- 동기화 객체 C가 얼마나 파워풀한가를 계측
	. 0, 1: 있으나 마나
	. 2: 2개 쓰레드 해결 가능, 3개 쓰레드 해결 불가능
	. 무한대: 가장 파워풀한 객체
- atomic 메모리로 n개 쓰레드의 합의 문제를 해결할 수 있는가?
	. wait-free 혹은 lock-free로
	. atomic_load(), atomic_store() 연산만을 사용해서 n개 쓰레드 합의 객체를 만들 수 있는가?

- 문제 단순화
	. 쓰레드 2개 : A, B
	. 각각 0과 1로 합의 시도
	. C는 합의 객체 (atomic 메모리 read/write로만 구현)
	. return값은 모두 0이던가, 모두 1이어야 한다.

- decide 알고리즘의 실행
	. 쓰레드 A와 쓰레드 B가 동시에 실행되며 return 값을 결정
	. atomic_load(), atomic_store()를 read/write라 부르자.
	. A와 B는 임의의 개수의 공유메모리에 대해 read/write 연산을 수행하면서 알고리즘 실행
	. 즉 return값에 영향을 미치는 연산은 공유메모리에 대한 read/write밖에 없다.
	  - 공유메모리의 값은 일종의 input와 output이다. input이 같으면 로컬변수는 항상 같은 값을 갖는다.
	    Output도 같지만 실행 순서에 따라 공유메모리에 저장되는 output이 달라진다.
	. return값은 공유메모리 연산이 어떠한 순서대로 실행되었느냐에 의해 결정된다.
	  - 같은 순서로 공유메모리 연산이 실행되면 항상 같은 return값이 나온다.
	. 알고리즘의 실행 과정 중 공유메모리에 대한 read/write를 따로 분리해서 생각해 보자.
	  - 이를 이동(move)이라고 부르자.

- 쓰레드는 합의를 이룰 때 까지 계산하면서 이동(move)한다.
	. wait-free이므로 언젠가는 이동이 끝난다.
	  - A와 B의 decide 호출이 완료된다.
	  - 이 시점에서는 return값이 1 또는 0으로 결정되어 있다.
	. 이동할 때만. 전체 실행 상태가 변경될 수 있다.
	  - 상태: return값의 결정 영향을 미치는 메모리나 레지스터의 값
	. 이동이 아니면 상태가 변경되지 않는다.
	  - 이동 결과에 의해서만 상태가 변경된다.
- 초기상태: 아무런 이동이 없는 경우
- 최종상태: 모든 쓰레드들이 이동을 마친 상태(프로토콜의 leaf)
	. decide 메소드가 결정된 값을 리턴한다.
- 일가(univalent) 상태: 앞으로 어떠한 이동을 하더라도 결정 값이 변화가 없는 경우
- 이가(bivalent) 상태: 최종 결정 값이 결정되지 않은 상태
	. 모든 트리의 상태는 일가 상태 또는 이가 상태
- 임계(critical) 상태
	. 현재 상태가 이가이다.
	. 다음의 이동으로 무조건 일가 상태가 된다.
	  - 즉 두 개의 child가 모두 일가 상태이다.

보조 정리
- 모든 2-쓰레드 합의 프로토콜의 초기상태는 이가이다.
	. A가 0, B가 1을 합의시킬 경우
	. A만 실행하면 0, B만 실행하면 1을 결정해야 한다.
	  -> 실행 순서에 따라 결과가 바뀐다.
	  -> 따라서 일가가 아니다.
- 모든 2-쓰레드 합의 프로토콜은 초기상태가 이가이다.
- 모든 무대기 합의 프로토콜은 임계 상태가 반드시 존재한다.
	. 트리의 높이는 유한하다.
	. 트리의 리프 노드는 모두 1가이다.
	. 마지막 2가 노드가 존재하는 높이가 있다.
	. 그 높이에 존재하는 모든 2가 노드는 임계상태이다.

명제: atomic 메모리로 2쓰레드 합의 문제를 해결할 수 있다.
- atomic 메모리로 구현했다고 가정하면
- decide를 알고리즘으로 구현했고 protocol을 그릴 수 있다.
- 임계상태가 반드시 존재하며, 그 때 가능한 이동 시나리오는
	. A: read, B: write or read
	  - A는 공유메모리를 읽으려고 하고 있고, B는 읽거나 쓰려고 하고 있다.
	. A: write r0, B: wirte r1 (r0 != r1)
	. A: write r, B write r

- A: read, B: write or read
	. A가 읽었는지 안 읽었는지 모르는 채로 B는 0일지 아닌지를 구분해야 한다.
- A: write r0, B: wirte r1 (r0 != r1)
	. 어느 순서로 썼는지 구분할 수 없다.
- A: write r, B write r
	. A가 썼는지 안 썼는지 알 수 없는 채로 B는 0과 1을 결정해야 하는 경우가 생긴다.
	  - A의 write r을 B의 write r이 덮어 쓴 경우와 아닌 경우를 B는 구분할 수 없다.
=> 임계 노드가 존재할 수 없다.

- Non Blocking 프로그램은 언젠가는 결과를 정해야 하는데, atomic memory의 Read/Write만으로는
  정해진 결과를 모든 쓰레드에게 알리는 것이 불가능하다.
	. wait-free이므로 결과를 정한 쓰레드가 이후의 공유메모리 연산으로 결과를 알려주지 않아도
	  다른 쓰레드들은 결과를 알아야 함.

FIFO QUEUE
- atomic 메모리로 2쓰레드 합의 객체를 구현할 수 없다면 무엇이 필요한가?
- Queue 객체가 있으면 해결이 가능한가?
- 가상의 큐를 가정하자.
	. 2 dequeuer queue
	. 2개의 쓰레드에서 동시에 deque를 했을 때 atomic하고 wait-free하게 동작하는 queue
- atomic 메모리의 합의 수는 1
- 2 dequeuer queue의 합의수는 적어도 2
- 즉 2 dequeuer queue는 atomic 메모리로 구현 불가능
- atomic 메모리만 가지고는 큐, 스택, 우선순위 큐, 집합, 리스트등의 무대기 구현을 작성할 수 없다.

증명
- A: deq, B: deq인 경우
	. A가 deq하자마자 B가 deq한 경우, B가 deq하자마자 A가 deq한 경우
	. C는 위의 두 경우를 구분할 수 없다.
- A: deq, B: enq인 경우
	. C가 볼 때 A가 먼저 수행되나 B가 먼저 수행되나 똑같다 (구별할 수 없다.)
- A: enq, B: enq인 경우


다중 대입 객체
- 그렇다면 N개 쓰레드의 합의 객체를 구현할 수 있는 합의수 N의 동기화 객체가 존재하는가?
-> 존재한다.
- 다중 대입 객체: 배열로 구성되며 복수의 원소를 atomic하게 변경할 수 있는 객체

- 원자적인 (n, n(n+1)/2) - 대입 객체는 최소 n의 합의수를 가진다.
- 따라서 대입 객체들을 HW적으로 지원하면 합의문제를 무대기로 해결할 수 있다.
	. HW구현 비용이 매우 크다.
	. 대안은? RMW

RMW (Read-Modify-Write)
- 하드웨어가 지원하는 동기화 연산의 한 종류
- 특수 명령어가 반드시 필요(Wait-Free가 되기 위해서는)
메소드 M은 함수 f에 대한 RMW이다.
	. 메소드 M이 원자적으로 현재 메모리의 값을 v에서 f(v)로 바꾸고 원래 값 v를 반환한다.

쓰레드끼리 정보 교환을 하려면 동기화 객체가 필요하다.
가장 대표적인 동기화 객체는 메모리
그냥 Read/Write 하면 신뢰할 수 없으니까 atomic memory를 사용한다.

Trivial한 atomic 연산이 있고 Non-Trivial한 atomic 연산이 있다.
Trivial은 그저 load, 아무짝에도 쓸모가 없다.
non-trivial은 다시 common2 ,non-common2로 나뉜다.

Common2 RMW 연산
- 많은 RMW 연산이 여기에 속한다.
- 정의
	. 두 개의 RMW 연산을 서로 다른 쓰레드에서 실행했을 때 누가 먼저 실행했는지
	  알 수 없는 경우
	. 함수 집합 F는 모든 값 v와 F에 속하는 모든 함수 fi와 fj에 대해 다음이 성립하면
	  Common2라고 한다.
	  - fi와 fj는 교환이 가능하거나
	  - 한 함수가 다른 함수를 덮어쓰는 경우
- 특징
	. 합의수 2를 갖는다.
	. 최근의 프로세서들에서는 제거되는 추세이다.
- Common2 RMW 레지스터의 합의 수는 2이다.
	. 두개의 쓰레드 A, B에 대한 임계영역이 존재하고, 같은 객체에 대한 RMW 연산이다.
	. ...

다시 CAS
- CAS(expected, update)
	. 레지스터의 값이 expected면 update로 바꾸고 true를 리턴
	. 레지스터의 값이 expected가 아니면 false를 리턴
- CAS는 무한대의 합의 수를 갖는다.
	. 임의의 합의수를 갖는 자료구조를 구현할 수 있다는 희망을 가진다.
	. 다음에 증명할 사항: 합의수 무한대인 동기화 연산으로 모든(n개의 쓰레드에서 non-blocking인)
	  자료구조를 구현할 수 있는가?
	  -> 그렇다.


만능성: 모든 알고리즘을 멀티 쓰레드 무대기로

합의의 의미
- 모든 무대기(wait-free) 동기화 객체는 합의 수(Consensus number)라는 능력의 차이가 있다.
- 작은 합의 수를 갖는 객체로 큰 합의 수 객체를 구현할 수 없다.

합의의 의의
- 불가능한 시도를 미연에 방지할 수 있다.
	. 예) 원자적 메모리를 가지고 4쓰레드 무대기 병렬 큐를 작성하려 하는 행위
- 구현 가능한 방법을 알고, 왜 그것이 구현 가능한지를 안다면 이를 최적화 할 때 더 잘 할 수 있다.

모든 자료구조의 무대기 동기화가 가능한가?
- 그렇다. 가능하다.
만능 객체
- 어떠한 객체(자료구조, 알고리즘)든 무대기 병렬객체로 변환시켜 주는 객체
	. 예) 싱글 쓰레드에서만 돌아가는 큐를 무대기 병렬 큐로 변환시켜 줄 수 있다.
- n개의 쓰레드에서 동작하는 만능객체는 합의 수 n 이상의 객체만 있으면 구현 가능하다.
	. 무한대의 합의 수 객체 CAS를 사용하면 쓰레드 개수에 상관없이 만능 객체를 구현할 수 있다.

만능의 정의
- 클래스 C 객체들과 원자적 메모리로 모든 객체를 무대기 구현으로 변환하는 것이 가능하면
  클래스 C는 만능이다.
	. 클래스 C로 모든 객체를 무대기로 변환 가능한데, 직접적으로 변환하지 않고
	  원자적 메모리를 사용해서 대상 객체를 약간 변형한 후 변환한다.
	. 변형: 여러 개의 메소드와 파라미터, 리턴값을 통합
- 일단 무잠금 만능객체를 알아보고 그것을 무대기 만능객체로 변형한다.

준비
- 순차 객체 A가 있고 이를 n-thread 상에서 무대기로 구현하려고 한다.
- 조건 : A는 결정적이다.(deterministic)	
	. 모든 객체의 초기상태는 항상 같은 상태이다.
	. 같은 상태에서 같은 입력을 주면 항상 같은 결과와 같은 완료 상태가 나온다.
	  -> 초기 상태에서 같은 입력 값을 동일한 순서로 입력하면 항상 같은 결과가 나온다.
	  - 입력의 순차적인 리스트를 로그(log)라고 한다.
	  - 즉 어떤 결과가 나올 지 예측 가능하다.

왜 무잠금 set은 쓰레드 개수 이상으로 성능 향상이 나오는가
- 싱글쓰레드에서 매우 비효율적으로 돌아간다.

무잠금 만능 구성
- 지금까지 객체 가해진 모든 메소드 호출의 리스트인 Log 보관
	. tail부터 시작하는 Node의 리스트
- 새로운 호출이 오면 Node를 생성한 후 Log의 head에 덧붙인다.
	. 합의 객체 활용
- A 객체를 생성한 후 Log에 있는 Invocation을 새로운 호출까지 적용시키고 그 결과를 반환한다.

구현의 트릭
- 노드마다 합의 객체를 갖고 있다.
	. 하나의 쓰레드는 head 배열을 통해 한번 호출한 합의 객체는 다시 호출하지 않도록 한다.
- 순차객체 A는 매 호출마다 새로 생성된다.
	. 다른 쓰레드는 절대 그 순차객체를 호출하지 않는다.
- 합의(Consensus)객체로 인해 한 Node의 Next Node는 어떤 쓰레드에서도 유일하다는 것을 보장 받는다.


무대기 만능 구성
- 루프가 있는데도 무대기이다. 왜냐하면 루프의 최대 횟수가 정해져 있기 때문이다.
- 쓰레드 개수만큼 실패한 Node가 있는지 확인한다. 그리고 그 Node를 먼저 Decide한다.
- 즉 정해진 Step 안에 반드시 끝나게 된다.


효율적인 lock
- 생각 없이 CAS를 써서 구현하면 너무 느리다.