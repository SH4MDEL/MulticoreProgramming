목표
- Non Blocking 자료 구조의 제작 실습
- 일반 자료구조를 멀티쓰레드 자료구조로 변환한다.
- Blocking 자료구조로부터 시작하여 단계별로 성능향상 기법을 적용한다.
- 최종적으로 Lock Free 자료구조를 제작한다.
- 각 자료구조의 성능을 비교한다.

목표 자료구조
- SET
	. 아이템의 중복을 허용하지 않는다.
	. 정렬되어 저장된다. (unordered_set이 아니다)
	  - 검색 효율이 증가한다.
	. 삽입 삭제의 효율성을 위해 연결리스트로 구현된다.
- 구현할 메소드
	. add(x) : 집합에 x 추가, 성공시 true 반환
	. remove(x) : 집합에서 x 제거, 성공시 true 반환
	. contains(x) : 집합에 x가 있다면 true 반환

추가적인 구현
- 보초 노드
	. 검색의 효율성을 위해 항상 존재하는 Head와 Tail 노드를 갖도록 한다.
	. Head는 MAXINT, Tail은 -MAXINT를 키로 갖는다.

구현 차례
- 성긴 동기화 (coarse-grained synchronization)
	. Lock 하나로 동기화 객체 전체를 감싸는 경우
	. 성능 향상이 있을 수가 없다.

- 세밀한 동기화 (fine-grained synchronization)
	. 전체 리스트를 한꺼번에 잠그는 것보다 개별 노드를 잠그는 것이
	  병행성을 향상시킬 수 있다.
	  - 전체 리스트에 대한 잠금을 두는 것이 아니라, 각각의 노드에 잠금을 둔다.
	  - Node에 Lock()과 Unlock() 메소드를 구현해야 한다.
	  - Node의 next field를 변경할 경우에는 반드시 lock을 얻은 후 변경해야 한다.
	. Add()와 Remove() 시점의 Pred, Curr가 가리키는 노드는 locking이 되어 있어야 한다.
	. Head부터 Node 이동을 할 때 lock을 잠그면서 이동해야 한다.
	. 병렬성이 있다.
	  - 그러나 잠금의 획득과 해제가 너무 빈번하다.
	  - 리스트가 길어지는 경우 성능이 매우 떨어진다.
	  - 무조건 head부터 시작하기 때문에 head에 bottle neck이 걸린다.

낙천적인 동기화 (optimistic synchronization_
- 이동 시 잠금을 하지 않는다. -> 오동작의 가능성이 있다.
- add/remove를 위해 prev를 수정하기 전에 prev를 잠근다.
- 이동 시 잠금을 하지 않는다
	. Data Race
	. 세밀한 동기화에서 이동 시 잠그는 이유가 있음.
- 해결
	. Crash (또는 무한루프)
	  - 제거된 Node의 Next가 Crash를 발생시키는 값을 갖지 않게 한다.
	  - 제거된 Node라도 Next를 따라가면 Tail이 나오게 한다.
	. 오동작
	  - prev와 curr를 잠근 후 제대로 잠갔는지 검사. (validation)
	  - prev와 curr를 잘못 잠갔을 경우 처음부터 다시 실행
- 구현 (임시 해결)
	. 제거된 노드를 'delete'하지 않는다.
	  - next 필드의 오염 방지, 결국엔 Tail 만남
	  - 하지만 memory lock -> 나중에 해결
	. validation 조건 검사
	  - 잠겨진 prev와 curr가 제거되지 않았고
	  - prev와 curr 사이에 다른 노드가 끼어들지 않았다.
- Validation
	1. prev, curr가 리스트에 존재한다.
	2. prev와 curr 사이에 다른 노드가 없다.
	. 충분한가? 충분하다.
	. 유효성 검사
	  - 다시 처음부터 검색해서 원래 prev, curr로 다시 올 수 있는지 확인한다.
	  -> prev, curr가 리스트에 존재하는지 확인
	  - prev->next == curr인 것을 확인한다.
	  -> 중간에 다른 노드가 끼어들지 않았음을 확인
- 낙천적 동기화 알고리즘은 기아를 겪을 수 있다.
	. validate가 실패하면 처음부터 다시 실행한다.
	. 다른 쓰레드들이 prev와 curr를 계속 수정하는 경우 계속 재시도를 하면서 지연될 수 있다.
	. 기아상태를 겪는 경우는 흔치 않은 경우이기 때문에 실제로는 잘 동작할 가능성이 크다.


- 게으른 동기화
- 비멈춤 동기화

