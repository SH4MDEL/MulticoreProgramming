Stack
- 후입선출 구조
- Push(), Pop() 메서드를 제공
- 성능은 큐보다 좋다. (캐시 친화적)

무제한 성긴 동기화 스택
- 연결 리스트로 구성되고 top 필드가 첫 노드를 가리킨다.
- 만약 스택이 비어있을 경우는 nullptr (보초 노드를 넣을 필요가 없다)
- -1을 스택에 추가하는 것은 고려하지 않는다.
- empty일 경우 pop()은 -2를 리턴한다.

무제한 무잠금 스택
- CAS를 이용하여 구현한다.
- Top의 변환을 CAS를 사용하여 non-blocking으로 구현한다.
- ABA 문제가 있으므로 delete를 하지 않는다.

- 메소드 호출은 스택의 top에 대해 성공한 CAS호출의 순서로 하나씩 진행되므로
  순차병목현상이 나타날 수 있다.
- new와 delete를 사용하면 ABA 문제가 생긴다.
	. Queue보다 문제가 생길 확률이 크다.

CAS 동기화의 문제
- 경쟁이 심할 경우 CAS 실패시 계속 재시도하는 것은 전체 시스템에 악영향을 줌
	. Thread가 많아질 수록 경쟁이 심해짐
	. 경쟁이 심할 경우 CAS가 실패할 확률이 높음
	  - 실패할 경우 성공할 때 까지 반복
	. CAS를 실행할 경우 같은 CPU의 모든 Core의 메모리 접근이 중단됨
	  - thread가 많아질 수록 잦은 메모리 접근 중단

BackOff
- 경쟁이 심할 경우 경쟁을 줄이자.
	. CAS의 실패는 경쟁이 심함을 뜻함.
	. CAS가 실패했을 경우 적절한 기간 동안 실행을 멈추었다가 재개하자.
	. CAS의 실패 확률이 낮아짐 -> 메모리 접근 중단 감소
- 적절한 기간
	. 처음에는 짧게
	. 계속 실패하면 점점 길게
	. 첫 번 시도에 성공하면 짧게
	. thread마다 기간을 다르게 해야 한다.
- 시스템 콜을 호출하는 오버헤드가 너무 크다.
	. CAS 몇 백 번을 막는 수준
	. chrono::high_resolution_clock을 사용한다.
	. (윈도우에서는 syscall을 하지 않지만 다른 곳에서 안한다는 보장이 없다)
	. 자체 루프
	. CPU 내장 타이머를 사용하자. (RDTSC, CPU 클럭에 비례함)

소거 백오프 스택
병행성 문제
- Queue나 Stack은 리스트의 말단 부분에서 잦은 충돌이 생긴다.
	. fine grain 타입의 최적화가 불가능하다.
	. Queue는 1/2로 충돌이 분산된다.
- Stack의 경우 충돌을 회피해서 병렬로 처리하는 방법이 가능
	. push, pop이 동시에 발생하는 경우 꼭 Stack에 넣어야 하나?
소거
- 많은 쓰레드가 서로 충돌할 경우 Stack에 넣지 않고 직접 Data를 주고 받도록 한다.
	. Stack을 통하지 말고 다른 객체를 통해 전달
- Lock-Free로 데이터를 주고 받도록 한다.
- 높은 경쟁률에 대비하여 주고 받는 별도의 객체를 복수로 준비한다.
- 만약 push와 pop이 거의 동시에 실행된다면 두 연산은 서로 취소되어 없어지고 스택에 접근하지 않는다.
- 이런 경우 push를 호출하는 쓰레드는 스택의 변동 없이 pop을 호출하는 쓰레드와 값을 교환할 수 있다.
	. 이 때 서로를 소거(Eliminate)하게 된다고 한다.

EliminationArray
- 원소 : 자료교환의 장소
- 여러 개의 원소를 갖고 부하를 분산
	. 서로 만나지 못할 경우도 있다.
	. 경쟁이 심할 경우 많은 장소가 효율적이고, 경쟁이 적을 경우는 장소가 적어야 한다.
쓰레드는 EliminationArray에서 임의(Random)의 항목을 골라서, 서로를 소거하려 시도
- 잘못된 종류의 호출을 만난 경우는 소거 실패
	. 예) push와 push, pop과 pop
- 임의로 하지 않고, 짝을 잘 맞추어 주면?
	. 정보 전달 자체가 오버헤드
	. Lock-Free로 하는 것은 어렵다. Open-Problem
Stack - Lock-Free BackOff에서 BackOff를 사용하지 않고, 대신에 소거를 시도한다.
- Elimination Array의 임의의 원소를 선택한다.
	. 임의 : 협조 자체가 오버헤드
	. Array의 크기는 가변
- 소거 시도
	. 아무도 없으면 기다림 (?)
	. 다른 쓰레드가 기다리고 있으면 교환
	. 이미 교환 중이면 재시도 (array size 증가 필요)
- 주의점
	. Time Out 필요 (array size 감소 필요)
	. 서로 만난 쓰레드가 push, pop의 조합이라는 보장이 없음
	  - 잘못된 만남은 실패

무잠금 교환자
- Elimination Array의 원소
- 두 개의 쓰레드가 Lock Free로 값을 교환할 수 있게 해주는 객체
- Exchange의 메소드를 갖고 있으며 두개의 쓰레드가 Exchange를 호출하면 서로의 입력 값을 리턴한다.
- 리턴 값은 교환값과 상태(성공, 실패, 타임아웃)이다.

소거
- 많은 쓰레드가 서로 충돌할 경우 Stack에 넣지 않고 직접 Data를 주고 받도록 한다.
	. Stack을 통하지 말고 다른 객체를 통해 전달
- Lock-Free로 Data를 주고 받도록 한다.
- 높은 경쟁률에 대비하여 주고 받는 별도의 객체를 복수로 준비한다.

구현
- Slot
	. 처음 교환을 시도한 쓰레드의 입력값을 저장하는 공간
	. 두 번째 쓰레드가 자신의 값을 넘겨 주는 공간
- 교환기는 3개의 상태를 가진다.
	. EMPTY
	  - 슬롯에 아무런 값도 저장되지 않은 상태
	. WAITING
	  - 처음 온 쓰레드에서 슬롯에 값을 하나 저장한 상태
	  - 다른 쓰레드가 와서 읽어가기를 기다리는 상태
	. BUSY
	  - 나중에 온 쓰레드가 슬롯의 값을 읽어가고 자신의 값으로 변경한 상태
	  - 처음 쓰레드는 아직 읽기를 완료하지 않음.

EMPTY
- CAS를 이용하여 슬롯에 자신의 아이템을 넣고 상태를 WAITING으로 바꾸기를 시도한다.
- 실패
	. 다른 쓰레드가 이미 CAS를 성공한 경우이다.
	. 다른 쓰레드가 WAITING으로 변경
	. 처음부터 다시 시도
- 성공
	. 스핀을 하면서(Blocking?) 다른 쓰레드가 교환을 끝내길 기다림
	. 교환이 완료(BUSY)된 후에는 대기 중이던 쓰레드는 아이템을 가져간 후 상태를 EMPTY로 바꾼다.
	  - EMPTY로 전환하는 일은 CAS를 이용하지 않는다.
	  - 오직 한 쓰레드만 작업하기 때문
- WAITING으로 바꾼 후 다른 쓰레드를 기다린다.
- 다른 쓰레드가 나타나지 않는다면
	. 대기중이던 쓰레드는 slot의 상태를 CAS를 호출하여 EMPTY로 전환
	. 성공시
	  - 시간제한 예외 발생
	. 실패시
	  - 다른 쓰레드가 나타나 교환을 완료하고 Busy로 변경했다는 의미이므로,
	    대기중이던 쓰레드는 교환을 완료한다.
WAITING
- 어떤 쓰레드가 대기중이며, 슬롯은 그 쓰레드의 아이템을 갖는다.
	. CAS를 이용하여 자신의 아이템을 적고 대기중인 쓰레드의 아이템을 얻는 것을 시도한다.
	  (BUSY 상태로 전환)
	. 실패시에는 처음부터 다시
	. 성공하면 얻은 아이템을 반환한다.
BUSY
- 현재 다른 두 쓰레드가 슬롯을 써서 값을 교환하고 있으므로 처음부터 다시
	  
ABA 문제
- 해당 알고리즘은 ABA문제를 일으키지 않는다.
	. ABA현상이 발생한다.
	. 하지만 그냥 진행해도 문제없다.
	. 교환대상이 바뀐 것 뿐이고 값도 그대로이기 때문에 아무 문제 없다.
	  - 사실은 CAS를 통해서 old값을 읽기 때문에 상태만 그대로이면 값이 바뀌는 것
	    까지도 문제가 없다.
타임아웃 문제
- 너무 짧은 교환 시간은 항상 실패하게 되므로 시간제한 기간을 고를 때 주의해야 한다.
	. 벤치마킹을 하면서 측정해야 한다.

소거 배열
- Exchange 객체의 배열
	. capacity개의 원소를 갖는다.
- visit()
	. 소거 배열이 갖고 있는 exchange원소 중 하나를 랜덤하게 선택해서 교환을 시도한다.
	. range값을 통해 random값의 범위를 조정할 수 있다.

Elimination Backoff Stack
- Lock Free Stack에서 CAS에 실패했을 경우 백오프를 하는 대신에 EliminationArray를 써서
  값의 교환을 시도한다.
- Push
1. CAS
	. 성공하면 리턴
2. 자신의 입력값을 인자로 visit()를 호출
	. timeout이 아니면
	  - 다른 쓰레드와의 교환이 성공했다는 뜻
	  - pop과의 교환이었으면 리턴
	  - pop과의 교환이 아니었으면 다시 CAS
	. timeout이면
	  - 다시 CAS




SKIPLIST
지금까지의 자료구조
- Set
	. Linked List Set, 검색시간 O(n)
	. 못써먹는다.

일반적인 트리 구조
- 트리 깊이의 균형을 유지하기 위하여 정기적인 재균형 작업이 필요
	. 하지만 병행 구조에서는 재균형작업이 병목이나 경쟁상태를 유발할 가능성이 있다.

SkipList
- 평균 O(logN) 검색시간을 갖는 자료구조
- 재균형작업이 필요 없음
- 랜덤 자료구조
	. 옵티멀한 방향으로 구현하려면 다른 쓰레드가 뭐하는지 알아내서 협의를 해야하는데
	  이게 오버헤드가 너무 크다.
	. 그래서 랜덤을 사용한다. 소거할 때 어디서 소거할지 랜덤으로
- Worst Case O(n)
	. 신경을 쓰지 않아도 될 정도로 확률이 낮음

- Set을 구현할 때 사용한 연결리스트의 확장
- 노드들이 추가 포인터를 갖고 있으며, 같은 레벨의 포인터끼리 연결됨. (next->next[n])
- 추가 링크(레벨 1 이상) 지름길을 만든다.
	. 노드를 추가하거나 제거할 때 지름길을 유지한다.
- 검색을 할 때 지름길을 우선 이용한다.

Add()
- 모든 링크가 연결되어야 add가 완료된 것이다.
- 어떻게 판별하는가? 다른 쓰레드는 결코 알 수 없다.
- flag를 넣자. 연결 되어있는지 확인(fullyLinked)

Remove()
- 검색 -> lock -> validate? -> 수정 -> unlock



Lock Free Skip List
- 3장의 LockFreeList를 사용
- 삽입과 삭제를 위해 CAS 사용
- 삭제 시에는 노드의 모든 next에 표시하여 논리적으로 제거한다.
- 물리적인 제거는 Find()에서 이루어진다.
	. Find()는 리스트를 순회하면서 표시된 노드를 만날때마다 잘라내어서
	  표시된 노드의 키는 절대 검색하지 않는다.

Add()
- Find()를 이용하여 노드가 이미 리스트에 있는지 확인하고 자신의 앞노드(prev[])와
  뒷노드(succ[])를 얻는다.
- 추가되는 시점의 정의
	. 게으른 동기화 : 모든 리스트가 연결되면
	. LF 동기화 : 0층이 연결되면
	  - find를 할 때 0층 연결 되었는가의 여부를 true, false로 리턴
- 새 노드는 최하층 리스트에 연결하여 논리적으로 추가하고 그 다음에 순서대로
  최상층까지 연결한다.
	. 최상층
	  - 새 노드가 고른 임의의 topLevel값이다.

Remove()
- Find()를 호출하여 표시되지 않고 대상키를 갖는 노드가 최하층 리스트에 있는지 확인
	. 최하층 리스트만 빼고 표시를 남겨서 논리적으로 제거
	. 최하층을 제외하고 전부 표시했다면 최하층의 next 참조에 표시
	  - 이 표시를 남기는 것에 성공하면 Find()를 통해 물리적 제거를 한다.
	  - 실패하면 충돌했으므로 return false;

Find()
- 게으른 동기화랑 비슷하다. 잘라내는 부분만 다르다.
- 스킵리스트를 순회하는데 각 층을 내려가며 리스트를 진행한다.
- 진행 중에 표시된 링크(marked)를 만나면 이 링크를 잘라내어서 표시된 노드의 키값을
  절대 보지 않는다.
- LockFreeSkipList를 검색하고 대상키가 집합에 있을 때만 true를 반환
	. 0레벨에 존재하고 마킹이 되지 않은 것을 집합에 존재한다고 정의
- 두 가지 속성을 만족
	. 표시된 연결(marked)은 순회하지 않는다. 대신 해당 층의 리스트에서
	  표시된 연결이 참조된 노드를 제거


Blocking이지만 잘 설계된 Blocking 알고리즘은 NonBlocking 알고리즘보다 고성능일 수 있다.
Lock Free는 무조건 CAS를 사용해 수정해야 한다. 
수정해야 할 부분이 많은 경우 여러 번 CAS를 시도해야 한다.

그러나 Blocking은 Convoying을 유발한다. 잘 나가다 확 느려질 수 있다.


Non-blocking Stack
- Back Off의 유용성(Core가 많은 머신에서)
- 부하 분산 테크닉
	. Elimination
Non-Blocking 검색 자료구조
- Skip-List
	. 평균 O(logN)의 검색 시간

총정리
- 왜 멀티쓰레드 프로그래밍을 해야 하는가?
	. 성능 때문이다.
	. 위험하지만 성능 때문에 어쩔 수 없이 사용한다.
- 멀티쓰레드 프로그램은 멀티코어 CPU에서 어떻게 사용되는가?
	. 운영체제가 놀고있는 코어에 실행 가능한 쓰레드를 할당.
	. Context Switch를 통해 골고루 실행시킨다.
- 내가 작성한 멀티쓰레드 프로그램이 왜 죽는가?
	. Data Race 때문이다.
- Lock을 사용하지 않을 때 쓰레드간의 동기화는 어떻게 구현하는 것이 좋은가?
	. Atomic한 자료구조를 통해 쓰레드간의 순서를 맞춰 준다.
- Non-Blocking 알고리즘이 무엇인가?
	. 어떻게 구현해야 하는가
	. Blocking보다 왜 좋은가? 어떤 경우에 좋은가?