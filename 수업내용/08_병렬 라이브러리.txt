- C++11
- OpenMP
- Indel Thread Building Block
- CUDA
- Transactional Memory
- 새로운 언어

C++11
- 성능 때문에 다루지 않은 것들
	. 시스템 호출로 구현되기 때문에 또는 Blocking으로 구현되므로
	. condition_variable, future, promise, async
	. coroutine
	  - 생성, 소멸 부하가 적다.

OpenMP
- C와 C++, FORTRAN에서 병렬프로그램을 가능하게 해주는 API
- 내부적으로 멀티쓰레드, 공유메모리를 사용한다.
- 컴파일러 디렉티브와 함수, 변수로 구성되어 있다.
	. 컴파일러 디렉티브: 컴파일러에게 요청(pragma pack, pragma once)
- 표준으로 지정되어있어서 대부분의 컴파일러에서 구현되어 있다.

특징
- 분산 메모리(분산 컴퓨터)에서는 사용할 수 없다.
- 최상의 공유메모리 사용 패턴을 보장하지 않는다.
- Data Dependency, Data Race, Deadlock 검사는 프로그래머가 해야 한다.
- 컴파일러가 알아서 기존 프로그램을 병렬로 변환해 주지 않는다.
  어느 부분을 어떻게 병렬화할지를 프로그래머가 지정해 주어야 한다.

프로그래밍 모델
- 공유메모리에서의 멀티쓰레드 구현
- 자동으로 병렬화를 하지 않고 사용자가 병렬화를 지정
- Fork-Join 모델
- 컴파일러 디렉티브에 의존
- Nesting 가능(병렬화의 겹침 허용)
	. 기존 쓰레드를 나눠서 잘 사용하게 해줌으로써 convoying 등 예방
- 동적 쓰레드 할당
- 메모리 일관성은 보장하지 않는다. 필요하면 FLUSH 명령을 사용해야 한다.
- FLUSH?
	. atomic_thread_fence

Do/For
- "schedule"
	. 루프가 병렬로 실행하는 방식을 지정
	. STATIC : 모든 쓰레드가 공평한 개수의 묶음을 실행
	. DYNAMIC : 먼저 끝난 쓰레드가 다음 묶음을 실행
- 묶음(chunk)
	. 쓰레드가 한번에 실행할 루프의 횟수
- "nowait"
	. 쓰레드의 실행을 동기화 하지 않음
	. 먼저 끝난 쓰레드가 다른 쓰레드의 작업종료를 기다리지 않고
	  다음 작업 실행

주의 사항
- For 병렬화에서 data dependency를 검사하지 않는다.
	. c[i] = c[i - 1] + a[i]; // 오동작
	. data dependency는 프로그래머의 책임



TBB
- Intel Thread Building Block
- 쓰레드 사용에 편리한 여러 API를 가짐
- Task 관리 기능 포함
- Intel CPU에서 동작함
	. 비공식적인 Android/ARM 버전도 존재함
- 최근 OneAPI라는 프로젝트에 통합되었으며, C++11과의 연동이 강조되고 있음
	. 특히 람다


- 메모리 일관성 지시
	. 지원에서 제거됨
	. C++의 memory_order를 사용하는 것이 낫다.